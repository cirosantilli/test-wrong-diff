#!/bin/bash
#set -x
trap "exit 1" SIGINT SIGHUP SIGTERM

export LANGUAGE="C"
export LC_ALL="C"
export LC_COLLATE="C"
export LC_CTYPE="en_US.UTF-8"
export LC_TIME="C"
export LANG="C"

INITDIR=boot-images/initrd
PKGDIR=boot-images/pkg-packages
DEVDIR=./packages/base/dev
MODDIR=boot-images/module-packages
PACDIR=./tmp-tree/packages
MAXIMAGE=786432
TOOLSDIR=./utils/tools
KERNEL_PARAMETERS=""
CONFDIR=./conf
export TOOLSDIR

libutil="chain complex cptime display fancyhello hdt ifcpu \
         keytest libmenu menu prdhcp pxechn rosh simple test \
         test2 vesamenu"

libcom32="chain cmd complex config display elf ethersel gfxboot \
          gpxecmd hdt hexdump host ifcpu ifcpu64 ifmemdsk ifplop \
          kbdmap kontron_wdt libmenu linux localboot lua mboot \
          pcitest pmload prdhcp pxechn reboot rosh sanboot sdi \
          simple sysdump test test2 vesamenu whichsys"

libmenu="complex display hdt simple test test2"

libgpl="cpuidtest disk dmitest hdt ifcpu lua vpdtest zzjson"

liblua="lua"

. packages/base/etc/thinstation.functions
. packages/base/etc/thinstation.env
. packages/base/etc/thinstation.defaults
. thinstation.conf.buildtime
export -f is_enabled

PATH=/usr/local/bin:/usr/bin:/bin:/sbin:/usr/sbin:/usr/local/sbin:/ts/bin

# set some defaults for builds that would produce unexpected results for legacy build scripts otherwise.
ts_mesa_3d=enabled
ts_localpkgs=true

# Show Command line Parameters

showhelp()
{
	echo "--license ACCEPT      Accept all licenses automatically"
	echo "--help                Show help then exit"
	echo "--autodl              Download all commercial addins automatically"
	echo "--buildtime FILENAME  Add buildtime conf file to squashfs image and build boot images only"
	echo "--kernel VERSION      Use this version of the kernel (rather than the default)"
	echo "--noimages            Build process but don't generate boot images"
	echo "--regenconf           Copy over default config example files again"
	echo "--removeall           Remove all commercial binaries then exit"
	echo "--savedir             Saves the tmp-tree directory for debugging and development purposes"
	echo "--savepkglist         Saves the package list files for documentation purposes"
	echo "--update              Will run all package update scripts <package>/build/update"
	echo "--allmodules          Will install all available kernel modules into the image"
}

## Remove Temp files

unmount_tmp()
{
	sleep 3
	if mounted ./tmp-tree/proc; then
		umount -f ./tmp-tree/proc
	fi
	if mounted ./tmp-tree/dev; then
		umount -f ./tmp-tree/dev
	fi
}

remove_files()
{
#	But only if we don't want to save them for debugging
	if [ -z "$SAVEDIR" ]; then
		if [ -e ./temp-efi ]; then
			rmdir ./temp-efi
		fi
		if [ -e /tmp/syslinux-com32 ]; then
			rm /tmp/syslinux-com32
		fi
		if [ -e ./tmp-tree ] ; then
			unmount_tmp
			rm -Rf ./tmp-tree/*
			rmdir ./tmp-tree
		fi
		if [ -e ./fastboot-tmp ] ;then
			rm -rf ./fastboot-tmp
		fi
		if [ -e ./liblist ] ; then
			rm ./liblist
		fi
		if [ -e ./packages.list ]; then
			rm ./packages.list
		fi
		if [ -e ./modules.list ]; then
			rm ./modules.list
		fi
		if [ -e ./wget_tmp ] ; then
			rm -Rf ./wget_tmp
		fi
		if [ -e ./liblist.tmp ] ; then
			rm ./liblist.tmp
		fi
		if [ -e $MODDIR ] ; then
			rm -R $MODDIR
		fi
		if [ -e ./build.image ] ; then
			rm ./build.image
		fi
	fi
}

remove_old_boot_files()
{
        if [ -e boot-images/initrd/added.files ]; then
                cat boot-images/initrd/added.files | while read file; do
                        rm "$file"
                        rmdir --ignore-fail-on-non-empty -p `dirname "$file"`
                done
                rm boot-images/initrd/added.files
        fi
}

## Add PKG Files to local Storage

addpkgs()
{
  if ls $1/*.pkg > /dev/null 2>&1 ; then
    rm $1/*.pkg
  fi
  if is_enabled $ts_localpkgs; then
    if ls $PKGDIR/*.pkg > /dev/null 2>&1 ; then
	mkdir -p $1
    	ln $PKGDIR/*.pkg $1
    fi
  fi
}

mounted()
{
	mountpoint -q $1
	return $?
}

lib_in_path()
{
#set -x
	for lpath in `cat lpaths.tmp` $filepath; do
		if [ -e ./tmp-tree$lpath/$1 ] || [ -e $pkgname$lpath/$1 ]; then
			return 0
		fi
	done
	if [ "`echo $filepath |sed -e 's|/|/\n|g' |grep -c '/'`" -gt "2" ]; then
		likely_rpath=`echo $filepath |cut -d '/' -f1-3`
		if [ -n "`find  $pkgname$likely_rpath -name $1`" ]; then
			return 0
		fi
	fi
#set +x
	return 1
}
export -f lib_in_path

calculate_lib_dependencies()
{
	unset DISPLAYED
	filename=$1
	(objdump -x $filename 2>/dev/null |grep -e NEEDED |cut -c 24-) \
	|while read libfile; do
		filepath=`dirname $filename | sed -e "s,$pkgname,,"`
		export filepath
		if ! lib_in_path $libfile && [ ! -e $pkgname/lib/$libfile ]; then
			if [ "$DISPLAYED" != "TRUE" ]; then
				echo "Adding library dependencies for `basename $filename`"
				DISPLAYED=TRUE
			fi
			libsource="`prt-get fsearch $libfile |grep -Ev 'Found|x-tool|^$' | cut -d " " -f3 |head -n1`"
			if [ -n "$libsource" ] && [ -e $libsource ]; then
				echo -e "\t\t\t$libfile"
				if [ ! -e $pkgname/lib ]; then
					mkdir -p $pkgname/lib
				fi
				linkdest=`readlink $libsource`
				if [ -n "$linkdest" ]; then
					[ ! -e $pkgname/lib/$libfile ] \
					&& $cputil `dirname $libsource`/$linkdest ./tmp-tree/lib/$libfile 2>/dev/null \
					&& echo "$pkgname/lib/$libfile" >> liblist.added
				else
					[ ! -e $pkgname/lib/$libfile ] \
					&& $cputil $libsource ./tmp-tree/lib/$libfile 2>/dev/null \
					&& echo "$pkgname/lib/$libfile" >> liblist.added
				fi
			else
				echo "Could not find $libfile !"
			fi
		fi
	done
}
export -f calculate_lib_dependencies

resolve_links()
{
	for link in `find $pkgname/lib -mindepth 1 -maxdepth 1 -type l \
        |grep -E 'so.[0-9]+$|so.[0-9]+.[0-9]+$|.so$' \
        |sort -u`; do
        	if [ -e $link ]; then
        		linkdest=`readlink $link`
			linkdir=`dirname $link`
	                rm $link
			cp -a $linkdir/$linkdest $link
        	fi
	done
}

lib_dependencies()
{
	echo -e "\nAdding Library Dependencies\n"

	if [ -e ./tmp-tree/etc/ld.so.conf ]; then
		cat ./tmp-tree/etc/ld.so.conf |grep -v include > lpaths.tmp
	fi
	if [ -e ./tmp-tree/etc/ld.so.conf.d ] && [ -n "`ls -A ./tmp-tree/etc/ld.so.conf.d`" ]; then
		cat ./tmp-tree/etc/ld.so.conf.d/* >> lpaths.tmp
	fi
	for pkgname in `echo "./tmp-tree" && find $PKGDIR -mindepth 1 -maxdepth 1`; do
                export pkgname
		if is_enabled $ts_stripelf; then
			export cputil="cp -a"
		else
			export cputil=ln
		fi
		if [ -d $pkgname/lib ]; then
			find $pkgname/lib -mindepth 1 -maxdepth 1 -type l |grep -e .so$ |grep -v python |xargs rm >/dev/null 2>&1
			resolve_links
			# Delete versions of files and links that are almost never used. Fingers Crossed.
			find $pkgname/lib -mindepth 1 -maxdepth 1 -name lib\* |grep -E '.so.[0-9]+.[0-9]+' |grep -Ev 'libwinpr|libfreerdp|libxfreerdp|nvidia' |xargs rm >/dev/null 2>&1
			find $pkgname/lib -mindepth 1 -maxdepth 1 -name lib\* |grep -E '.so.[0-9]+.[0-9]+.[0-9]+' |grep -Ev 'libwinpr|libfreerdp|libxfreerdp|nvidia' |xargs rm >/dev/null 2>&1
			find $pkgname/lib -mindepth 1 -maxdepth 1 -type f |grep -E 'libnss_[a-z]+\-[0-9]+.[0-9]+.so$' |xargs rm >/dev/null 2>&1
		fi
		find $pkgname -type f > filelist
		file -e encoding -e tokens -e compress -e ascii -e apptype -e tar -e cdf -f filelist -n -r \
		|grep -e ELF \
		|cut -d: -f1 > liblist.final 2>/dev/null
		rm filelist
		while [ -s liblist.final ]; do
			parallel --record-env
			cat liblist.final |sort -u|sort -R |parallel --env _ --will-cite calculate_lib_dependencies
			rm liblist.final
			if [ -e liblist.added ]; then
				mv liblist.added liblist.final
			fi
		done
	done
	ldconfig -X -r tmp-tree 2>/dev/null
	rm lpaths.tmp
}

copy_module()
{
	unset copied
	local rpath=`find /lib/modules/$2 -name $1 -printf %h |cut -d "/" -f5-`
	local src=/lib/modules/$2/$rpath/$1
	local dest=$3/lib/modules/$2/$rpath
	if [ ! -e $src ]; then
		echo "Notice! Module $1 not found for kernel $2"
		return 1
	fi
	if [ ! -e $dest/$1 ]; then
		mkdir -p $dest
		cp $src $dest/$1 > /dev/null 2>&1
		if [ "$?" == "0" ]; then
			copied="$dest/$1"
			return 0
		fi
	else
		return 0
	fi
	return 1
}

list_all_packages()
{
	echo "./tmp-tree"
	find $MODDIR/ -mindepth 1 -maxdepth 1
	find $PKGDIR/ -mindepth 1 -maxdepth 1
}

list_mod_packages()
{
	echo "./tmp-tree"
	find $MODDIR/ -mindepth 1 -maxdepth 1
}

module_dependencies()
{
echo -e "\nAdding modules that are dependencies of selected modules"
for pkgname in `list_all_packages`; do
	if [ -e $pkgname/lib/modules/$KERNVER ]; then
		find $pkgname/lib/modules/$KERNVER -name \*.ko > ./modules.list
		while [ -s ./modules.list ]; do
			for module in `cat modules.list`; do
				allfirm `basename $module`
				depends="`modinfo -F depends $module |sed -e 's/,/ /g'`"
				# Checks for already existing modules
				for depend in $depends; do
					if [ -z "`find ./tmp-tree/lib/modules/$KERNVER -name ${depend}.ko`" ] && \
					   [ -z "`find $pkgname/lib/modules/$KERNVER -name ${depend}.ko`" ]; then
						needed="$needed ${depend}.ko"
					fi
				done
				if [ -n "$needed" ]; then
					echo "Adding dependency in `basename $pkgname` for module `basename $module`"
					for depend in $needed; do
						echo -e "\t\t\t\t$depend"
						if copy_module $depend $KERNVER $pkgname; then
							echo $copied >> modules.copied
							allfirm $depend
						fi
					done
				fi
				unset needed
			done
			rm modules.list
			if [ -e modules.copied ]; then
				mv modules.copied modules.list
			fi
		done
		rm -f modules.list
	fi
done
}

module_package_dependencies()
{
	# Adding additional modules and packages which are dependencies of other modules
	echo -e "\nAdding $KERNVER module dependencies on other modules and packages not picked up by depmod"
	for pkgname in `list_mod_packages`; do
		(ls ./kernel/dependencies_module/ ) |
		while read module; do
			if [ -n "`find ./tmp-tree/lib/modules/$KERNVER -name ${module}.ko`" ] || \
			   [ -n "`find $pkgname/lib/modules/$KERNVER -name ${module}.ko`" ]; then
				(cat ./kernel/dependencies_module/$module ) |
				while read type name; do
					case $type in
						module)
							if [ -z "`find ./tmp-tree/lib/modules/$KERNVER -name ${name}.ko`" ] && \
							   [ -z "`find $pkgname/lib/modules/$KERNVER -name ${name}.ko`" ]; then
								if ! is_enabled $DISPLAYED; then
									echo "Adding module dependencies for $module"
									DISPLAYED=true
								fi
								echo -e "\t\t\t\tModule : $name"
								copy_module ${name}.ko $KERNVER $pkgname
								touch /tmp/dirty
							fi
						;;
						firmware)
							if is_enabled $ts_allfirmware; then
								if [ -z "`find ./tmp-tree/lib/firmware -name ${name}`" ]; then
									if ! is_enabled $DISPLAYED; then
										echo "Adding module dependencies for $module"
										DISPLAYED=true
									fi
									copy_firmware ${name}
								fi
							fi
						;;
						package)
							if [ ! -e $PACDIR/$name.package ] && \
							   [ ! -e $PACDIR/$name.pkg ]; then
								if [ -d ./packages/$name ]; then
									if ! is_enabled $DISPLAYED; then
										echo "Adding module dependencies for $module"
										DISPLAYED=true
									fi
									echo "cp -Rp --remove-destination ./packages/$name/* ./tmp-tree > /dev/null 2>&1">>\
										$PACDIR/$name.package
									touch /tmp/dirty
									echo -e "\t\t\t\tPackage : $name"
								else
									echo "Not Found $name!!"
								fi
							elif [ -z "`find ./tmp-tree/lib/modules -name ${module}.ko`" ] && \
								 [ -n "`find $pkgname/lib/modules/$KERNVER -name ${module}.ko`" ] && \
								 [ ! -e $PACDIR/$name.pkg ]; then
								if [ -d  ./packages/$name ]; then
									echo "building-pkg $name"
									echo -e "cp -Rp ./packages/$name $PKGDIR" >> $PACDIR/$name.pkg
									touch /tmp/dirty
								else
									echo "Not Found $name!!"
								fi
							fi
						;;
						*)
							continue
						;;
					esac
				done
				unset DISPLAYED
			fi
		done
	done
}

strip_files()
{
	if is_enabled $ts_stripelf;then
		echo -e "\nStripping Enabled"
		rampre="`du -s ./tmp-tree|cut -f1`"
		echo -e "\tRAM Usage before stripping\t$rampre KiloBytes"
		for i in `find tmp-tree -type f |grep -v -f exclusions |xargs file |grep -e ELF |grep -v /lib/modules/ |grep -v e3$ |cut -d ":" -f1` ;
			do
				strip --strip-all -R.note -R.comment $i
			done
		rampost="`du -s ./tmp-tree|cut -f1`"
		echo -e "\tRAM Usage after stripping\t$rampost KiloBytes"
		echo -e "\tTotal RAM Savings\t\t$(( $rampre - $rampost )) KiloBytes\n"
	fi
}

make_initrd()
{

   cd tmp-tree
	if [ "$ts_fastboot" == "true" ] || [ "$ts_fastboot" == "lotsofmem" ] ;then
		echo -e "\nMaking initramfs - Fastboot Enabled"
		../fastboot/fastboot-mangle "$INITDIR" "$ts_fastboot" "$ts_hardlinkfs" "$ts_fb_comp_extra"
	else
		if [ -e $INITDIR/lib.squash ] ; then
			rm $INITDIR/lib.squash
		fi
		echo -e "\nMaking initramfs"
	fi
	echo -e "\tFixing-Up links"
	rm usr/bin usr/sbin usr/lib usr/icons usr/X11R7 usr/share usr/etc usr/local share usr/libexec
	ln -sf /bin usr/bin
	ln -sf /sbin usr/sbin
	ln -sf /lib usr/lib
	ln -sf /libexec usr/libexec
	ln -sf /etc usr/etc
	ln -sf /lib usr/share
	ln -sf /lib share
	ln -sf / usr/X11R7
	ln -sf /lib/icons usr/icons
	ln -sf / usr/local

	if [ "$ts_hardlinkfs" == "true" ]; then
		hardlink -t -m .
	fi
	if [ "$ts_sametimestmp" == "true" ]; then
		timestamp="`date +%Y%m%d`0000"
		echo -e "\tSetting all timestamps to $timestamp"
		for file in `find .`; do
			touch -c -h -t $timestamp $file
		done
	fi
	if [ "$ts_initrdcmd" == "squashfs" ]; then
		mksquashfs . ../$INITDIR/initrd $ts_squashopt -always-use-fragments -no-recovery -no-exports -no-xattrs -noappend
	elif [ "$ts_initrdcmd" == "none" -o "$ts_initrdcmd" == "" ]; then
		find . -print0 | cpio --null -oV --format=newc > ../$INITDIR/initrd
	else find . -print0 | cpio --null -oV --format=newc | $ts_initrdcmd > ../$INITDIR/initrd
	fi
	cd ..
   chmod 755 $INITDIR/initrd
   IMAGESIZE=`du -k $INITDIR/initrd | cut -f1`
   if [ $IMAGESIZE -gt $MAXIMAGE ] ; then
           echo "ERROR, Image file is too Big, maximum size is $MAXIMAGE remove"
           echo "some packages!"
           echo "Build Aborted!!"
           echo
           rm $INITDIR/initrd
           remove_files
           exit 1
   fi
}

package_dependencies ()
{
	ls $PACDIR/*.$1 > packages.list 2>/dev/null
	while [ -s packages.list ]; do
		(cat packages.list ) |
		while read filename; do
			package=`basename $filename .$1`
			if [ -s packages/$package/dependencies ] ; then
				(cat packages/$package/dependencies |grep -v ^#) |
				while read name cross; do
					if	[ "$1" = "package" ] || \
           done
	fi
done

# Checks for and removes any remaining keymap.pkg files
# It does this as keymaps are merged into there parent files

for filename in `find $PKGDIR -maxdepth 1 -name "keymaps-*"`
do
	rm -R $filename
	keymapname=`basename $filename`
	rm $PACDIR/$keymapname.pkg
done
}

copy_firmware()
{
	if [ -n "$2" ]; then
		firmfiles=`find -L /lib/firmware/ -name $1\* | grep $2`
	else
		firmfiles=`find -L /lib/firmware/ -name $1\*`
	fi
	if [ -n "$firmfiles" ]; then
		for firmfile in $firmfiles; do
			firmpath=./tmp-tree/lib/firmware/`echo $firmfile |cut -d '/' -f4-`
			if [ ! -e $firmpath ]; then
				echo "Firmware: `basename $firmfile`"
				if [ ! -d ${firmpath%/*} ] ;then
					mkdir -p ${firmpath%/*}
				fi
				cp $firmfile ${firmpath%/*}/.
			fi
		done
	else
		echo -e "\tNotice, Firmware $1 not found"
#		echo "$1" >> /missing
	fi
}

read_conf()
{
if [ -z "$1" ] ;
	then CONF_FILE=$CONFIG_FILE
	else CONF_FILE=$1
fi
(cat $CONF_FILE; echo) | # make sure there is a LF at the end
while read type name args
do
    type=`echo $type | sed -e s///g | sed -e 's/\&/\\\&/g'`
    name=`echo $name | sed -e s///g | sed -e 's/\&/\\\&/g'`
    args=`echo $args | sed -e s///g | sed -e 's/\&/\\\&/g'`
    case $type in
    \#*|"") continue
	    ;;
    param)
	echo "Parameter: $name"
	echo "ts_$name=$args" >> $PACDIR/$name.param
	;;
    package)
	echo "Package: $name"
	if [ -d ./packages/$name ]; then
	   echo "cp -Rp --remove-destination ./packages/$name/* ./tmp-tree > /dev/null 2>&1">>\
	     $PACDIR/$name.package
	else
	   echo "Not Found $name!!"
	fi
	;;
    machine)
	read_conf ./machine/$name/module.list
	if [ -e ./machine/$name/firmware.list ]; then
		read_conf ./machine/$name/firmware.list
	fi
	if [ -e ./machine/$name/param.list ]; then
		read_conf ./machine/$name/param.list
	fi
	if [ -e ./machine/$name/package.list ]; then
		read_conf ./machine/$name/package.list
	fi
	if [ -e ./machine/$name/etc ]; then
		cp -rf ./machine/$name/etc ./tmp-tree/.
	fi
	;;
    module)
	if ! is_enabled $ALLMODULES; then
		if [ -e ./kernel/alias/$name ] ; then
			name=`cat ./kernel/alias/$name`
		fi
		for KERNVER in $KERNVERS; do
		        if [ -e `find /lib/modules/$KERNVER -name ${name}.ko` ] ; then
				echo "Module $KERNVER: $name"
				copy_module ${name}.ko $KERNVER ./tmp-tree
			else
				echo "Error, Module $name not found"
			fi
		done
	fi
	if [ `make_caps X$args` == "XFORCE" ]; then
		echo $name `echo $args | cut -f1 -d#` >> ./tmp-tree/etc/modules
	fi
